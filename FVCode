/**
 * VILLAGE SIMULATION ENGINE (SIMPLIFIED)
 * Generates story events based on guest data from FRC
 * Reads directly from FRC - no intermediate sheets needed
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const SIM_CONFIG = {
  EVENTS_PER_CYCLE_MIN: 3,
  EVENTS_PER_CYCLE_MAX: 8,
  STORY_LOG_SHEET: 'Village Story Log',
  LAST_STATE_SHEET: 'Simulation State',

  // Hamlet definitions
  HAMLETS: {
    'LARK_HOLLOW': {
      name: 'Lark Hollow',
      symbol: 'üéª',
      interests: ['Music', 'Art/Design', 'Fashion']
    },
    'PINE_RIDGE': {
      name: 'Pine Ridge',
      symbol: 'üèπ',
      interests: ['Fitness', 'Hiking/Outdoors', 'Sports']
    },
    'HEARTHSTEAD': {
      name: 'Hearthstead',
      symbol: 'ü•ñ',
      interests: ['Cooking', 'Fashion', 'Travel']
    },
    'IRONFORD': {
      name: 'Ironford',
      symbol: '‚öôÔ∏è',
      interests: ['Gaming', 'Technology', 'Cars']
    },
    'ELDERWOOD': {
      name: 'Elderwood',
      symbol: 'üìö',
      interests: ['Reading', 'Education', 'Science', 'Health Sciences']
    }
  }
};

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Get active villagers directly from FRC
 * Simplified - no Village Bios sheet needed
 */
function getActiveVillagers() {
  const guests = getCheckedInGuests();

  return guests.map(guest => ({
    uid: guest.uid,
    screenName: guest.screenName || 'Unknown',
    interests: [guest.interest1, guest.interest2, guest.interest3].filter(Boolean),
    socialStance: guest.socialStance || 3,
    ddd: guest.dddScore || 0,
    hamlet: null,
    position: { x: Math.random(), y: Math.random() },
    connections: []
  }));
}

/**
 * Generate a new story cycle
 */
function generateStoryCycle() {
  try {
    const villagers = getActiveVillagers();

    if (villagers.length === 0) {
      throw new Error('No guests found in FRC sheet');
    }

    // Assign hamlets
    assignHamlets(villagers);

    // Detect new arrivals
    const newArrivals = detectNewArrivals(villagers);

    // Generate events
    const events = generateStoryEvents(villagers);

    // Write to log
    writeStoryLog(events, newArrivals);

    // Update state
    updateSimulationState(villagers);

    SpreadsheetApp.getUi().alert(
      'Story Cycle Complete!',
      `Generated ${events.length} events. ${newArrivals.length} new arrivals.`,
      SpreadsheetApp.getUi().ButtonSet.OK
    );

    return { events, newArrivals };

  } catch (error) {
    SpreadsheetApp.getUi().alert('Error', error.message, SpreadsheetApp.getUi().ButtonSet.OK);
    throw error;
  }
}

/**
 * Assign hamlets based on interests
 */
function assignHamlets(villagers) {
  for (const villager of villagers) {
    if (villager.hamlet) continue;

    // Score each hamlet
    const scores = {};
    for (const [key, hamlet] of Object.entries(SIM_CONFIG.HAMLETS)) {
      scores[key] = 0;
      for (const interest of villager.interests) {
        if (hamlet.interests.some(hi => interest.toLowerCase().includes(hi.toLowerCase()))) {
          scores[key] += 1;
        }
      }
    }

    // Assign to best match or random
    const maxScore = Math.max(...Object.values(scores));
    if (maxScore > 0) {
      villager.hamlet = Object.keys(scores).find(key => scores[key] === maxScore);
    } else {
      const hamletKeys = Object.keys(SIM_CONFIG.HAMLETS);
      villager.hamlet = hamletKeys[Math.floor(Math.random() * hamletKeys.length)];
    }
  }
}

/**
 * Detect new arrivals since last cycle
 */
function detectNewArrivals(villagers) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const stateSheet = ss.getSheetByName(SIM_CONFIG.LAST_STATE_SHEET);

  if (!stateSheet) {
    return villagers; // First run - all are new
  }

  const stateData = stateSheet.getDataRange().getValues();
  const lastUIDs = new Set(stateData.slice(1).map(row => row[0]));

  return villagers.filter(v => !lastUIDs.has(v.uid));
}

/**
 * Calculate connections between villagers
 */
function calculateConnections(villagers) {
  for (const v1 of villagers) {
    v1.connections = [];

    for (const v2 of villagers) {
      if (v1.uid === v2.uid) continue;

      let strength = 0;

      // Same hamlet bonus
      if (v1.hamlet === v2.hamlet) strength += 3;

      // Shared interests
      const shared = v1.interests.filter(i => v2.interests.includes(i));
      strength += shared.length * 2;

      // Social stance compatibility
      if (Math.abs(v1.socialStance - v2.socialStance) <= 1) strength += 1;

      if (strength > 0) {
        v1.connections.push({
          villager: v2,
          strength: strength,
          sharedInterests: shared
        });
      }
    }

    v1.connections.sort((a, b) => b.strength - a.strength);
  }
}

/**
 * Generate story events
 */
function generateStoryEvents(villagers) {
  const events = [];
  const numEvents = Math.floor(
    Math.random() * (SIM_CONFIG.EVENTS_PER_CYCLE_MAX - SIM_CONFIG.EVENTS_PER_CYCLE_MIN + 1)
  ) + SIM_CONFIG.EVENTS_PER_CYCLE_MIN;

  calculateConnections(villagers);

  for (let i = 0; i < numEvents; i++) {
    const event = generateRandomEvent(villagers);
    if (event) events.push(event);
  }

  return events;
}

/**
 * Generate a random event
 */
function generateRandomEvent(villagers) {
  if (villagers.length === 0) return null;

  const eventTypes = ['COOPERATION', 'TRADE', 'CULTURAL', 'RIVALRY', 'MORALE'];
  const type = eventTypes[Math.floor(Math.random() * eventTypes.length)];

  switch (type) {
    case 'COOPERATION':
      return generateCooperationEvent(villagers);
    case 'TRADE':
      return generateTradeEvent(villagers);
    case 'CULTURAL':
      return generateCulturalEvent(villagers);
    case 'RIVALRY':
      return generateRivalryEvent(villagers);
    case 'MORALE':
      return generateMoraleEvent(villagers);
    default:
      return null;
  }
}

/**
 * Generate cooperation event
 */
function generateCooperationEvent(villagers) {
  if (villagers.length < 2) return null;

  const v1 = villagers[Math.floor(Math.random() * villagers.length)];
  if (v1.connections.length === 0) return null;

  const v2 = v1.connections[0].villager;
  const hamlet = SIM_CONFIG.HAMLETS[v1.hamlet];

  const templates = [
    `@${v1.screenName} and @${v2.screenName} collaborated on a project in ${hamlet.name}.`,
    `In ${hamlet.name}, @${v1.screenName} taught @${v2.screenName} a new skill.`,
    `@${v1.screenName} and @${v2.screenName} helped rebuild the ${hamlet.name} square.`
  ];

  return {
    type: 'COOPERATION',
    participants: [v1.screenName, v2.screenName],
    hamlets: [hamlet.name],
    story: templates[Math.floor(Math.random() * templates.length)]
  };
}

/**
 * Generate trade event
 */
function generateTradeEvent(villagers) {
  if (villagers.length < 2) return null;

  const v1 = villagers[Math.floor(Math.random() * villagers.length)];
  const diffHamlet = v1.connections.filter(c => c.villager.hamlet !== v1.hamlet);

  if (diffHamlet.length === 0) return null;

  const v2 = diffHamlet[0].villager;
  const h1 = SIM_CONFIG.HAMLETS[v1.hamlet];
  const h2 = SIM_CONFIG.HAMLETS[v2.hamlet];

  return {
    type: 'TRADE',
    participants: [v1.screenName, v2.screenName],
    hamlets: [h1.name, h2.name],
    story: `${h1.symbol} ${h1.name} and ${h2.symbol} ${h2.name} established a trade route. @${v1.screenName} and @${v2.screenName} sealed the deal.`
  };
}

/**
 * Generate cultural event
 */
function generateCulturalEvent(villagers) {
  if (villagers.length === 0) return null;

  const host = villagers[Math.floor(Math.random() * villagers.length)];
  const hamlet = SIM_CONFIG.HAMLETS[host.hamlet];

  const templates = [
    `${hamlet.symbol} ${hamlet.name} hosted a festival. @${host.screenName} led the celebrations.`,
    `Music filled ${hamlet.name} as @${host.screenName} organized a concert.`,
    `@${host.screenName} invited all hamlets to ${hamlet.name}'s harvest feast.`
  ];

  return {
    type: 'CULTURAL',
    participants: [host.screenName],
    hamlets: [hamlet.name],
    story: templates[Math.floor(Math.random() * templates.length)]
  };
}

/**
 * Generate rivalry event
 */
function generateRivalryEvent(villagers) {
  if (villagers.length < 2) return null;

  const v1 = villagers[Math.floor(Math.random() * villagers.length)];
  const v2 = villagers[Math.floor(Math.random() * villagers.length)];

  if (v1.uid === v2.uid) return null;

  const h1 = SIM_CONFIG.HAMLETS[v1.hamlet];
  const h2 = SIM_CONFIG.HAMLETS[v2.hamlet];

  return {
    type: 'RIVALRY',
    participants: [v1.screenName, v2.screenName],
    hamlets: [h1.name, h2.name],
    story: `@${v1.screenName} and @${v2.screenName} challenged each other to a friendly contest.`
  };
}

/**
 * Generate morale event
 */
function generateMoraleEvent(villagers) {
  if (villagers.length === 0) return null;

  const villager = villagers[Math.floor(Math.random() * villagers.length)];
  const hamlet = SIM_CONFIG.HAMLETS[villager.hamlet];

  return {
    type: 'MORALE',
    participants: [],
    hamlets: [hamlet.name],
    story: `${hamlet.symbol} ${hamlet.name} celebrated a day of rest and community spirit.`
  };
}

/**
 * Write story events to log
 */
function writeStoryLog(events, newArrivals) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let storySheet = ss.getSheetByName(SIM_CONFIG.STORY_LOG_SHEET);

  if (!storySheet) {
    storySheet = ss.insertSheet(SIM_CONFIG.STORY_LOG_SHEET);
    storySheet.getRange(1, 1, 1, 5).setValues([['Timestamp', 'Type', 'Hamlets', 'Participants', 'Story']]);
    storySheet.getRange(1, 1, 1, 5).setFontWeight('bold');
  }

  const timestamp = new Date();

  // Write new arrivals
  for (const villager of newArrivals) {
    const hamlet = SIM_CONFIG.HAMLETS[villager.hamlet];
    storySheet.appendRow([
      timestamp,
      'ARRIVAL',
      hamlet.name,
      villager.screenName,
      `‚ú® @${villager.screenName} arrived at ${hamlet.symbol} ${hamlet.name}!`
    ]);
  }

  // Write events
  for (const event of events) {
    storySheet.appendRow([
      timestamp,
      event.type,
      event.hamlets.join(', '),
      event.participants.join(', '),
      event.story
    ]);
  }

  storySheet.sort(1, false);
}

/**
 * Update simulation state
 */
function updateSimulationState(villagers) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let stateSheet = ss.getSheetByName(SIM_CONFIG.LAST_STATE_SHEET);

  if (!stateSheet) {
    stateSheet = ss.insertSheet(SIM_CONFIG.LAST_STATE_SHEET);
  } else {
    stateSheet.clear();
  }

  stateSheet.getRange(1, 1, 1, 4).setValues([['UID', 'Screen Name', 'Hamlet', 'Last Seen']]);

  const data = villagers.map(v => [
    v.uid,
    v.screenName,
    SIM_CONFIG.HAMLETS[v.hamlet].name,
    new Date()
  ]);

  if (data.length > 0) {
    stateSheet.getRange(2, 1, data.length, 4).setValues(data);
  }
}

/**
 * Get active villagers for map (called from HTML)
 */
function getActiveVillagersForMap() {
  try {
    const villagers = getActiveVillagers();

    if (villagers.length > 0 && !villagers[0].hamlet) {
      assignHamlets(villagers);
    }

    return {
      success: true,
      villagers: villagers.map(v => ({
        uid: v.uid,
        screenName: v.screenName,
        hamlet: SIM_CONFIG.HAMLETS[v.hamlet]?.name || 'Unknown',
        interests: v.interests,
        socialStance: v.socialStance,
        ddd: v.ddd
      }))
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Get story data for HTML
 */
function getStoryData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const storySheet = ss.getSheetByName(SIM_CONFIG.STORY_LOG_SHEET);

  if (!storySheet) {
    return { stories: [], hamlets: SIM_CONFIG.HAMLETS };
  }

  const data = storySheet.getDataRange().getValues();
  const stories = [];

  for (let i = data.length - 1; i >= 1; i--) {
    stories.push({
      timestamp: data[i][0],
      type: data[i][1],
      hamlets: data[i][2],
      participants: data[i][3],
      story: data[i][4]
    });
  }

  return {
    stories: stories.slice(0, 100),
    hamlets: SIM_CONFIG.HAMLETS
  };
}

/**
 * Reset simulation
 */
function resetSimulation() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert(
    'Reset Simulation?',
    'Clear all story logs and simulation state?',
    ui.ButtonSet.YES_NO
  );

  if (response === ui.Button.YES) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    const storySheet = ss.getSheetByName(SIM_CONFIG.STORY_LOG_SHEET);
    if (storySheet) ss.deleteSheet(storySheet);

    const stateSheet = ss.getSheetByName(SIM_CONFIG.LAST_STATE_SHEET);
    if (stateSheet) ss.deleteSheet(stateSheet);

    ui.alert('Reset Complete', 'All logs cleared!', ui.ButtonSet.OK);
  }
}

/**
 * Show map
 */
function showFarmvilleMap() {
  const html = HtmlService.createHtmlOutputFromFile('FarmvilleMap')
    .setWidth(1400)
    .setHeight(800)
    .setTitle('Village Map');
  SpreadsheetApp.getUi().showModalDialog(html, 'Village Map');
}

/**
 * Show chronicle
 */
function showVillageChronicle() {
  const html = HtmlService.createHtmlOutputFromFile('VillageChronicle')
    .setWidth(1600)
    .setHeight(900)
    .setTitle('Village Chronicle');
  SpreadsheetApp.getUi().showModalDialog(html, 'Village Chronicle');
}

/**
 * Show story log
 */
function showStoryLog() {
  const html = HtmlService.createHtmlOutputFromFile('StoryLog')
    .setWidth(1000)
    .setHeight(700)
    .setTitle('Story Log');
  SpreadsheetApp.getUi().showModalDialog(html, 'Story Log');
}

/**
 * Add menu
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üèòÔ∏è Village Sim')
    .addItem('Generate Story Cycle', 'generateStoryCycle')
    .addItem('Show Story Log', 'showStoryLog')
    .addSeparator()
    .addItem('Show Village Map üó∫Ô∏è', 'showFarmvilleMap')
    .addItem('Show Chronicle üìú', 'showVillageChronicle')
    .addSeparator()
    .addItem('Reset Simulation', 'resetSimulation')
    .addToUi();
}
